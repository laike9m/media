<ul>
  <li><a href="#-1">国家和软件项目的相似性</a></li>
  <li><a href="#-2">国家的兴衰 → 代码的生长和腐化</a></li>
  <li><a href="#-3">社会观念/政治体制 → 软件项目的架构</a></li>
  <li><a href="#-4">应用举例：为什么完美的体制不存在？</a></li>
  <li><a href="#-5">应用举例：为什么错误的政策会造成深刻且持久的伤害？</a></li>
  <li><a href="#-6">应用举例：为什么小国容易治理？</a></li>
  <li><a href="#-7">应用举例：为什么美国如此强大？</a></li>
  <li><a href="#-8">总结</a></li>
</ul>
<p>最近我发现软件工程和国家的演化有诸多相似之处。很多复杂的历史/政治/经济/社会问题，映射到软件工程领域后都变得好懂了。因此来分享一下这个观察世界的角度，相信程序员们会很容易接受。我姑且把它称做“软件社会学”。软件社会学不是一种（严肃的）理论，而是一种可以用来认识世界的工具。</p>

<h2 id="-1">国家和软件项目的相似性</h2>

<p>首先也是最重要的一点，我们要意识到国家和软件项目的相似性。这里列举几点，其实还有更多：</p>

<ul>
<li>都有“生命”，且生命周期较长</li>
<li>都在不断变化</li>
<li>参与其中的人带来变化，变化也反过来影响每个人</li>
</ul>

<p>解释一下第一条。有人会说我的代码还没上线项目就被毙了，生命周期哪里长了？没错，但同样也有还没诞生就夭折的国家。再者，这里的“较长”并非指绝对时长，而是相对于变化速度来说的——代码变化快，即便它只存在了几个月，也可能有几百几千次提交了。</p>

<p>虽然我们无法严格地把两者对应起来，但不妨先建立一个框架，后面才有的讨论。</p>

<h2 id="-2">国家的兴衰 → 代码的生长和腐化</h2>

<p>这点相信凡是在稍具规模的项目上工作过的人都能理解。正如国家在刚建立时一般朝气蓬勃，一个项目在刚开始的时候总能快速迭代。这时候代码量和技术债都很少，改了甚至就能直接 push 上线。人也少，大家对项目和彼此都很熟悉，工作起来效率很高。</p>

<p>随着时间推移，项目的代码量多了起来，团队规模也越来越大（姑且假设项目很成功）。工程师们逐渐发现，原来了如指掌的代码渐渐读不懂了，经常要问同事这里怎么工作，那里为什么这么改；明明就改了一行，却 break 了不知道哪个角落的测试，而你却连这个测试在干嘛都不知道；代码规范也从一开始的统一，变成了八仙过海各显神通；合理抽象更是不存在了，大家都是能跑就行哪管那么多。</p>

<p>假设这时突然来了个年轻有为的程序员，大手一挥说这么干不行，我们要制定规范、改进代码质量，让开发速度重新快起来。结果呢？可能项目里的老人不鸟他，可能老板觉得他不出活，也可能只是单纯的工作量太大他完成不了——总之这种事基本没有成功的案例。国家也类似，到了末期全身都是积弊，想改也没法改了。这是不以个人意志为转移的。</p>

<h2 id="-3">社会观念/政治体制 → 软件项目的架构</h2>

<p>这是我觉得最有意思的一个对应。我们都知道合理的系统架构对于后续开发的重要性，因为很多东西一旦确定下来后面就很难改了。国家也是类似，比如大家最熟悉的两个例子：</p>

<ul>
<li>秦始皇：中国第一架构师，提出的“大一统”架构延续了两千多年</li>
<li>独立宣言：提出了“人人生而平等”的理念，作为美国的基石延续至今</li>
</ul>

<p>自这些架构提出之后，虽然后人不断小修小补，提出各种不同的解读，但这些架构在社会中只会越嵌越深，以致无法被撼动。几百年几千年过去，这时候你会发现初始架构的强大之处——不管上层代码再怎么变，国家就按这个架构一直跑下去了。</p>

<h2 id="-4">应用举例：为什么完美的体制不存在？</h2>

<p>我们都知道随着环境/需求/人员/预算等状况的变动，一个曾经很合适的架构会变得不合适（比如难以扩展），反之亦然。社会观念和政治体制也是如此，比如曾经高效的奴隶制在历史长河中就被淘汰了，这种例子不要太多。</p>

<p>我们还知道，软件工程里是<a href="https://zh.wikipedia.org/zh-hans/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">没有银弹</a>的，同样也没有完美的体制。总有人说美国三权分立很完美，结果 Trump 安排的三个大法官完美演示了什么叫卡系统 bug，那倒车开得叫一个快。事实就是，在一个极端复杂的系统里是不存在“完美”的，只有永恒的 trade-off。</p>

<h2 id="-5">应用举例：为什么错误的政策会造成深刻且持久的伤害？</h2>

<p>由于人类很可悲地生活在线性的时间里，发生的事情就是发生了。错误的设计会造成深刻且持久的伤害，因为新代码会遵循这个设计编写，从而变成未来重构的负担——错误持续得越久，负担也就越大。有人形象地把改代码比作一边开车一边换车轮。事实的确如此，理性的公司都不可能抛掉老代码来个完全重写。George Hotz 在推特尝试过，但失败了，因为这事本来就不可能成。类似的，实行一个政策很容易，改掉却很难，于是错误（技术债）就这么越积越多，直到无法维持下去的那一天。</p>

<h2 id="-6">应用举例：为什么小国容易治理？</h2>

<p>独立开发者们写代码发布新版本总是很快，因为依赖少。不论是加新功能、修bug、重构，甚至是更新架构，都相对容易。随着团队扩大，这些原本容易的事也变得困难了。</p>

<p>国家类似，越小的国家越容易治理，根本原因在于复杂度是和规模正相关的，甚至如果考虑内部依赖，这种复杂度的增长是指数级的。一套对小国适用的政策很可能对大国不适用——就好像你很难在 Google 这种体量的公司用创业公司的风格去工作。</p>

<h2 id="-7">应用举例：为什么美国如此强大？</h2>

<p>美国的例子实在是太有趣了，因为它完全就是从英国这个 repo fork 出去，然后又重写的一个版本。因为是重写，所以可以抛掉君主制这个积累了几千年的技术债；因为是重写，所以 co-founder 们重新审视了一下人类历史，找到了当时最新最合理的架构；还是因为重写，奴隶制这种错误的设计没有在代码中扎根太深，因此在后续大版本中被移除，但即便这样美国也付出了沉重代价。美国历史短，但这正是它最大的优势。它就 Google 和Meta 这些曾经的创业公司一样，通过发现一块新的大陆，然后称霸全球。</p>

<p>然而即便是美国，技术债在二百五十年中还是不可避免地越积越多：枪支、毒品、贫富差距、社会两极化等等。人类若想找到新的灯塔，也必须通过建立新的国家——比如火星殖民、加密货币（？），但这就是另一个故事了。</p>

<h2 id="-8">总结</h2>

<p>一旦你意识到这种对应，便会发现两者的相似性远不止文中写的这些。这种重新认识世界的过程将是个有趣的体验。</p>

<p>我不认为软件社会学是一种理论，因为它基于类比而非严肃的论证。我更愿意把它当做趁手的工具。工具只要能用就好，我们不用特别关心原理，也无需严格证明它的正确性。或许未来有人能深化一下把它做成一种理论，谁知道呢。</p>
